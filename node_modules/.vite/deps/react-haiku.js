import {
  require_jsx_runtime
} from "./chunk-6PXSGDAH.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-haiku/dist/hooks/useHover.js
var import_react = __toESM(require_react());
function useHover() {
  const [hovered, setHovered] = (0, import_react.useState)(false);
  const ref = (0, import_react.useRef)(null);
  const onMouseEnter = (0, import_react.useCallback)(() => setHovered(true), []);
  const onMouseLeave = (0, import_react.useCallback)(() => setHovered(false), []);
  (0, import_react.useEffect)(() => {
    if (ref.current) {
      ref.current.addEventListener("mouseenter", onMouseEnter);
      ref.current.addEventListener("mouseleave", onMouseLeave);
      return () => {
        var _a, _b;
        (_a = ref.current) == null ? void 0 : _a.removeEventListener("mouseenter", onMouseEnter);
        (_b = ref.current) == null ? void 0 : _b.removeEventListener("mouseleave", onMouseLeave);
      };
    }
    return void 0;
  }, []);
  return { ref, hovered };
}

// node_modules/react-haiku/dist/helpers/event.js
var on = (obj, ...args) => {
  if (obj && obj.addEventListener)
    obj.addEventListener(...args);
};
var off = (obj, ...args) => {
  if (obj && obj.addEventListener)
    obj.removeEventListener(...args);
};

// node_modules/react-haiku/dist/hooks/useConfirmExit.js
var import_react2 = __toESM(require_react());
function useConfirmExit(enabled, message = "Are you sure you want to exit?") {
  const handler = (0, import_react2.useCallback)((e) => {
    const finalEnabled = typeof enabled === "function" ? enabled() : true;
    if (!finalEnabled) {
      return;
    }
    e.preventDefault();
    if (message) {
      e.returnValue = message;
    }
    return message;
  }, [enabled, message]);
  (0, import_react2.useEffect)(() => {
    if (!enabled) {
      return;
    }
    on(window, "beforeunload", handler);
    return () => off(window, "beforeunload", handler);
  }, [enabled, handler]);
}

// node_modules/react-haiku/dist/hooks/useFavicon.js
function useFavicon(defaultHref = null) {
  const set = (hrefToSet) => {
    var _a;
    const link = document.querySelector("link[rel*='icon']") || document.createElement("link");
    link.type = "image/x-icon";
    link.rel = "shortcut icon";
    link.href = hrefToSet;
    (_a = document.getElementsByTagName("head")[0]) == null ? void 0 : _a.appendChild(link);
  };
  const setFavicon = (href) => defaultHref && !href ? set(defaultHref) : set(href);
  return { setFavicon };
}

// node_modules/react-haiku/dist/hooks/useLocalStorage.js
var import_react5 = __toESM(require_react());

// node_modules/react-haiku/dist/hooks/useEventListener.js
var import_react4 = __toESM(require_react());

// node_modules/react-haiku/dist/hooks/useIsomorphicLayoutEffect.js
var import_react3 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react3.useLayoutEffect : import_react3.useEffect;

// node_modules/react-haiku/dist/hooks/useEventListener.js
function useEventListener(eventName, handler, element) {
  const savedHandler = (0, import_react4.useRef)(handler);
  useIsomorphicLayoutEffect(() => {
    savedHandler.current = handler;
  }, [handler]);
  (0, import_react4.useEffect)(() => {
    const targetElement = (element == null ? void 0 : element.current) || window;
    if (!(targetElement && targetElement.addEventListener)) {
      return;
    }
    const eventListener = (event) => savedHandler.current(event);
    targetElement.addEventListener(eventName, eventListener);
    return () => {
      targetElement.removeEventListener(eventName, eventListener);
    };
  }, [eventName, element]);
}

// node_modules/react-haiku/dist/hooks/useLocalStorage.js
function useLocalStorage(key, initialValue) {
  const readValue = (0, import_react5.useCallback)(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item = window.localStorage.getItem(key);
      return item ? parseJSON(item) : initialValue;
    } catch (error) {
      console.error(`Error getting storage key “${key}”:`, error);
      return initialValue;
    }
  }, [initialValue, key]);
  const [storedValue, setStoredValue] = (0, import_react5.useState)(readValue);
  const setValueRef = (0, import_react5.useRef)();
  setValueRef.current = (value) => {
    try {
      const newValue = value instanceof Function ? value(storedValue) : value;
      window.localStorage.setItem(key, JSON.stringify(newValue));
      setStoredValue(newValue);
      window.dispatchEvent(new Event("local-storage"));
    } catch (error) {
      console.warn(`Error adding "${key}" to storage:`, error);
    }
  };
  const setValue = (0, import_react5.useCallback)((value) => {
    var _a;
    return (_a = setValueRef.current) == null ? void 0 : _a.call(setValueRef, value);
  }, []);
  (0, import_react5.useEffect)(() => {
    setStoredValue(readValue());
  }, []);
  const handleStorageChange = (0, import_react5.useCallback)(() => setStoredValue(readValue()), [readValue]);
  useEventListener("storage", handleStorageChange);
  useEventListener("local-storage", handleStorageChange);
  return [storedValue, setValue];
}
function parseJSON(value) {
  try {
    return value === "undefined" ? void 0 : JSON.parse(value ?? "");
  } catch {
    return void 0;
  }
}

// node_modules/react-haiku/dist/hooks/useDebounce.js
var import_react6 = __toESM(require_react());
function useDebounce(value, delay = 500) {
  const [debounced, setDebounced] = (0, import_react6.useState)(value);
  (0, import_react6.useEffect)(() => {
    const timer = setTimeout(() => setDebounced(value), delay);
    return () => clearTimeout(timer);
  }, [value, delay]);
  return debounced;
}

// node_modules/react-haiku/dist/hooks/useClickOutside.js
function useClickOutside(ref, handler, event = "mousedown") {
  useEventListener(event, (event2) => {
    const el = ref == null ? void 0 : ref.current;
    if (!el || el.contains(event2.target)) {
      return;
    }
    handler(event2);
  });
}

// node_modules/react-haiku/dist/hooks/useSingleEffect.js
var import_react7 = __toESM(require_react());
function useSingleEffect(effect) {
  const destroy = (0, import_react7.useRef)();
  const calledOnce = (0, import_react7.useRef)(false);
  const renderAfterCalled = (0, import_react7.useRef)(false);
  if (calledOnce.current)
    renderAfterCalled.current = true;
  (0, import_react7.useEffect)(() => {
    if (calledOnce.current) {
      return;
    }
    calledOnce.current = true;
    destroy.current = effect();
    return () => {
      if (!renderAfterCalled.current) {
        return;
      }
      if (destroy.current)
        destroy.current();
    };
  }, []);
}

// node_modules/react-haiku/dist/hooks/useFirstRender.js
var import_react8 = __toESM(require_react());
function useFirstRender() {
  const isFirst = (0, import_react8.useRef)(true);
  if (isFirst.current) {
    isFirst.current = false;
    return true;
  }
  return isFirst.current;
}

// node_modules/react-haiku/dist/hooks/useScript.js
var import_react9 = __toESM(require_react());
function useScript(src) {
  const [status, setStatus] = (0, import_react9.useState)(src ? "loading" : "idle");
  (0, import_react9.useEffect)(() => {
    if (!src) {
      setStatus("idle");
      return;
    }
    let script = document.querySelector(`script[src="${src}"]`);
    if (!script) {
      script = document.createElement("script");
      script.src = src;
      script.async = true;
      script.setAttribute("data-status", "loading");
      document.body.appendChild(script);
      const setAttributeFromEvent = (event) => {
        script == null ? void 0 : script.setAttribute("data-status", event.type === "load" ? "ready" : "error");
      };
      script.addEventListener("load", setAttributeFromEvent);
      script.addEventListener("error", setAttributeFromEvent);
    } else {
      setStatus(script.getAttribute("data-status"));
    }
    const setStateFromEvent = (event) => setStatus(event.type === "load" ? "ready" : "error");
    script.addEventListener("load", setStateFromEvent);
    script.addEventListener("error", setStateFromEvent);
    return () => {
      if (script) {
        script.removeEventListener("load", setStateFromEvent);
        script.removeEventListener("error", setStateFromEvent);
      }
    };
  }, [src]);
  return status;
}

// node_modules/react-haiku/dist/hooks/useMediaQuery.js
var import_react10 = __toESM(require_react());
function attachMediaListener(query, callback) {
  try {
    query.addEventListener("change", callback);
    return () => query.removeEventListener("change", callback);
  } catch (e) {
    query.addListener(callback);
    return () => query.removeListener(callback);
  }
}
function computeInitialValue(query, initialValue) {
  if (initialValue !== void 0) {
    return initialValue;
  }
  if (typeof window !== "undefined" && "matchMedia" in window) {
    return window.matchMedia(query).matches;
  }
  return false;
}
function useMediaQuery(query, initialValue) {
  const [matches, setMatches] = (0, import_react10.useState)(computeInitialValue(query, initialValue));
  const ref = (0, import_react10.useRef)();
  (0, import_react10.useEffect)(() => {
    if ("matchMedia" in window) {
      ref.current = window.matchMedia(query);
      setMatches(ref.current.matches);
      return attachMediaListener(ref.current, (event) => setMatches(event.matches));
    }
    return void 0;
  }, [query]);
  return matches;
}

// node_modules/react-haiku/dist/hooks/usePrefersTheme.js
function usePrefersTheme(initialValue) {
  return useMediaQuery("(prefers-color-scheme: dark)", initialValue === "dark") ? "dark" : "light";
}

// node_modules/react-haiku/dist/hooks/useMousePosition.js
var import_react11 = __toESM(require_react());
function useMousePosition() {
  const [position, setPosition2] = (0, import_react11.useState)({ x: 0, y: 0 });
  const { max } = Math;
  const target = (0, import_react11.useRef)();
  const setMousePosition = (event) => {
    var _a;
    if (target.current) {
      const r2 = (_a = event == null ? void 0 : event.currentTarget) == null ? void 0 : _a.getBoundingClientRect();
      const x = max(0, Math.round(event.pageX - r2.left - (window.pageXOffset || window.scrollX)));
      const y = max(0, Math.round(event.pageY - r2.top - (window.pageYOffset || window.scrollY)));
      setPosition2({ x, y });
    } else
      setPosition2({ x: event.clientX, y: event.clientY });
  };
  (0, import_react11.useEffect)(() => {
    const element = (target == null ? void 0 : target.current) ? target.current : document;
    element.addEventListener("mousemove", setMousePosition);
    return () => element.removeEventListener("mousemove", setMousePosition);
  }, [target.current]);
  return { target, ...position };
}

// node_modules/react-haiku/dist/hooks/useUrgentUpdate.js
var import_react12 = __toESM(require_react());
var r = (v) => (v + 1) % 1e6;
function useUrgentUpdate() {
  const [_, u] = (0, import_react12.useReducer)(r, 0);
  return u;
}

// node_modules/react-haiku/dist/hooks/useLeaveDetection.js
var import_react13 = __toESM(require_react());
function useLeaveDetection(onLeave) {
  (0, import_react13.useEffect)(() => {
    document.documentElement.addEventListener("mouseleave", onLeave);
    return () => document.documentElement.removeEventListener("mouseleave", onLeave);
  }, []);
}

// node_modules/react-haiku/dist/hooks/useInputValue.js
var import_react14 = __toESM(require_react());
function handleChange(setValue) {
  return (val) => {
    if (!val) {
      setValue(val);
    } else if (typeof val === "object" && "nativeEvent" in val) {
      const { currentTarget } = val;
      if (currentTarget.type === "checkbox") {
        setValue(currentTarget.checked);
      } else {
        setValue(currentTarget.value);
      }
    } else {
      setValue(val);
    }
  };
}
function useInputValue(initialState) {
  const [value, setValue] = (0, import_react14.useState)(initialState);
  return [value, handleChange(setValue)];
}

// node_modules/react-haiku/dist/hooks/useToggle.js
var import_react15 = __toESM(require_react());
function useToggle(initialValue, options) {
  const [state, setState] = (0, import_react15.useState)(initialValue);
  const handleToggle = () => setState((current) => current === options[0] ? options[1] : options[0]);
  const toggle = (value) => typeof value !== "undefined" ? setState(value) : handleToggle();
  return [state, toggle];
}
function useBoolToggle(initialValue = false) {
  return useToggle(initialValue, [true, false]);
}

// node_modules/react-haiku/dist/hooks/useClipboard.js
var import_react16 = __toESM(require_react());
function useClipboard({ timeout = 500 } = {}) {
  const [error, setError] = (0, import_react16.useState)(null);
  const [copied, setCopied] = (0, import_react16.useState)(false);
  const [copyTimeout, setCopyTimeout] = (0, import_react16.useState)(void 0);
  const handleCopyResult = (hasError) => {
    clearTimeout(copyTimeout);
    setCopyTimeout(setTimeout(() => setCopied(false), timeout));
    setCopied(hasError);
  };
  const copy = (value) => {
    if ("clipboard" in navigator) {
      navigator.clipboard.writeText(value).then(() => handleCopyResult(true)).catch((err) => setError(err));
    } else {
      setError(new Error("Error: navigator.clipboard is not supported"));
    }
  };
  const reset = () => {
    setError(null);
    setCopied(false);
    clearTimeout(copyTimeout);
  };
  return { copy, reset, error, copied };
}

// node_modules/react-haiku/dist/hooks/useHold.js
var import_react17 = __toESM(require_react());
var isTouchEvent = (e) => "touches" in e;
var preventDefault = (e) => {
  if (!isTouchEvent(e)) {
    return;
  }
  if (e.touches.length < 2 && e.preventDefault) {
    e.preventDefault();
  }
};
var useHold = (callback, { doPreventDefault = true, delay = 1e3 } = {}) => {
  const timeout = (0, import_react17.useRef)();
  const target = (0, import_react17.useRef)();
  const start = (0, import_react17.useCallback)((event) => {
    if (doPreventDefault && event.target) {
      on(event.target, "touchend", preventDefault, { passive: false });
      target.current = event.target;
    }
    timeout.current = setTimeout(() => callback(event), delay);
  }, [callback, delay, doPreventDefault]);
  const clear = (0, import_react17.useCallback)(() => {
    timeout.current && clearTimeout(timeout.current);
    if (doPreventDefault && target.current) {
      off(target.current, "touchend", preventDefault);
    }
  }, [doPreventDefault]);
  return {
    onMouseDown: (e) => start(e),
    onTouchStart: (e) => start(e),
    onMouseUp: clear,
    onMouseLeave: clear,
    onTouchEnd: clear
  };
};

// node_modules/react-haiku/dist/hooks/useIdle.js
var import_react18 = __toESM(require_react());
var defaultEvents = [
  "keypress",
  "mousemove",
  "touchmove",
  "click",
  "scroll"
];
var defaultOptions = {
  events: [...defaultEvents],
  initialState: true
};
function useIdle(timeout, options = {}) {
  const { events, initialState } = { ...defaultOptions, ...options };
  const [idle, setIdle] = (0, import_react18.useState)(initialState);
  const timer = (0, import_react18.useRef)(void 0);
  (0, import_react18.useEffect)(() => {
    const handleEvents = () => {
      setIdle(false);
      if (timer.current) {
        window.clearTimeout(timer.current);
      }
      timer.current = window.setTimeout(() => setIdle(true), timeout);
    };
    events == null ? void 0 : events.forEach((event) => document.addEventListener(event, handleEvents));
    return () => events == null ? void 0 : events.forEach((event) => document.removeEventListener(event, handleEvents));
  }, [timeout]);
  return idle;
}

// node_modules/react-haiku/dist/hooks/useTitle.js
function useTitle(title) {
  useIsomorphicLayoutEffect(() => {
    if (typeof title === "string" && title.trim().length > 0) {
      document.title = title.trim();
    }
  }, [title]);
}

// node_modules/react-haiku/dist/hooks/useScrollPosition.js
var import_react19 = __toESM(require_react());
var getPosition = () => typeof window !== "undefined" ? { x: window.scrollX, y: window.scrollY } : { x: 0, y: 0 };
var setPosition = ({ x, y }) => {
  if (typeof window !== "undefined") {
    const scrollOptions = { behavior: "smooth" };
    if (typeof x === "number")
      scrollOptions.left = x;
    if (typeof y === "number")
      scrollOptions.top = y;
    window.scrollTo(scrollOptions);
  }
};
function useScrollPosition() {
  const [currentPosition, setCurrentPosition] = (0, import_react19.useState)(getPosition());
  ["scroll", "resize"].forEach((item) => useEventListener(item, () => setCurrentPosition(getPosition())));
  return [currentPosition, setPosition];
}

// node_modules/react-haiku/dist/hooks/useUpdateEffect.js
var import_react20 = __toESM(require_react());
function useUpdateEffect(effect, deps) {
  const isFirstRender = useFirstRender();
  (0, import_react20.useEffect)(() => {
    if (!isFirstRender) {
      return effect();
    }
  }, deps);
}

// node_modules/react-haiku/dist/hooks/useCookie.js
var import_react22 = __toESM(require_react());

// node_modules/react-haiku/dist/hooks/useCookieListener.js
var import_react21 = __toESM(require_react());

// node_modules/react-haiku/dist/helpers/cookie.js
var parseToDataType = (value, isItRetry = false) => {
  var _a;
  try {
    return value === "undefined" || value === void 0 ? void 0 : JSON.parse(value);
  } catch (e) {
    if (!isItRetry) {
      return parseToDataType(`"${(_a = value == null ? void 0 : value.replaceAll) == null ? void 0 : _a.call(value, '"', "")}"`, true);
    }
    return void 0;
  }
};
var parseToCookieType = (value) => {
  if (typeof value === "string") {
    return value;
  }
  return JSON.stringify(value);
};
var getCookie = (name) => {
  const value = `; ${document.cookie}`;
  const [_, cookie] = value.split(`; ${name}=`);
  return cookie ? parseToDataType(cookie.split(";")[0]) : cookie;
};
var getCookies = (cookies = []) => {
  if (cookies.length)
    return cookies.reduce((result, cookie) => ({ ...result, [cookie]: getCookie(cookie) }), {});
  return Object.fromEntries(document.cookie.split("; ").map((c) => {
    const [key, value] = c.split("=");
    return [key, parseToDataType(value)];
  }));
};
var setCookie = (name, value, expireDays) => {
  const date = /* @__PURE__ */ new Date();
  const millisecondsInADay = 24 * 60 * 60 * 1e3;
  const expireDate = date.getTime() + expireDays * millisecondsInADay;
  date.setTime(expireDate);
  const expires = `expires=${date.toUTCString()}`;
  document.cookie = `${name}=${parseToCookieType(value)}; ${expires}; path=/;`;
};
var deleteCookie = (name) => {
  document.cookie = `${name}=; path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;`;
};

// node_modules/react-haiku/dist/hooks/useCookieListener.js
var useCookieListener = (effect, cookies) => {
  const cookieValues = (0, import_react21.useRef)(getCookies(cookies));
  (0, import_react21.useEffect)(() => {
    const cookieOnChange = () => {
      const currentCookiesValues = getCookies(cookies);
      Object.entries(cookieValues.current).forEach(([cookieKey, cookieValue]) => {
        const currentCookie = currentCookiesValues[cookieKey];
        if (parseToCookieType(currentCookie) !== parseToCookieType(cookieValue)) {
          cookieValues.current = {
            ...cookieValues.current,
            [cookieKey]: currentCookie
          };
          effect(currentCookie, cookieKey);
        }
      });
    };
    const cookieInterval = setInterval(cookieOnChange, 1e3);
    return () => {
      clearInterval(cookieInterval);
    };
  }, [effect, cookies]);
};

// node_modules/react-haiku/dist/hooks/useCookie.js
var useCookie = (key, initialValue, expireDays = 365) => {
  const [cookieValue, setCookieValue] = (0, import_react22.useState)(getCookie(key) ?? parseToDataType(parseToCookieType(initialValue)));
  useSingleEffect(() => {
    if (typeof getCookie(key) === "undefined") {
      setCookie(key, initialValue, expireDays);
    }
  });
  useCookieListener((value) => {
    setCookieValue(value);
  }, [key]);
  const setValue = (value) => {
    setCookieValue(value);
    setCookie(key, value, expireDays);
  };
  const deleteValue = () => {
    deleteCookie(key);
  };
  return [cookieValue, setValue, deleteValue];
};

// node_modules/react-haiku/dist/hooks/useInterval.js
var import_react23 = __toESM(require_react());
function useInterval(callback, initialDelay) {
  if (typeof callback !== "function") {
    throw new Error(`Invalid parameter type. 'callback' should be a function but received ${callback}`);
  }
  if (typeof initialDelay !== "number") {
    throw new Error(`Invalid parameter type. 'initialDelay should be a number but received ${initialDelay}'`);
  }
  const savedCallback = (0, import_react23.useRef)();
  const [delay, setDelay] = (0, import_react23.useState)(initialDelay);
  (0, import_react23.useEffect)(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react23.useEffect)(() => {
    function tick() {
      if (!savedCallback.current) {
        return;
      }
      savedCallback.current();
    }
    if (delay !== null) {
      let id = setInterval(tick, delay);
      return () => clearInterval(id);
    }
  }, [delay]);
  const start = (delay2) => {
    setDelay(delay2 || initialDelay);
  };
  const stop = () => {
    setDelay(null);
  };
  return { start, stop };
}

// node_modules/react-haiku/dist/hooks/useSize.js
var import_react24 = __toESM(require_react());
var useSize = (ref) => {
  const [dimensions, setDimensions] = (0, import_react24.useState)({
    width: 0,
    height: 0
  });
  (0, import_react24.useEffect)(() => {
    if (!ref.current) {
      return;
    }
    const updateDimensions = () => {
      const { clientWidth, clientHeight } = ref.current;
      setDimensions({ width: clientWidth, height: clientHeight });
    };
    const resizeObserver = new ResizeObserver(updateDimensions);
    updateDimensions();
    resizeObserver.observe(ref.current);
    return () => {
      resizeObserver.disconnect();
    };
  }, [ref.current]);
  return dimensions;
};

// node_modules/react-haiku/dist/hooks/useBatteryStatus.js
var import_react25 = __toESM(require_react());
function useBatteryStatus() {
  const [batteryStatus, setBatteryStatus] = (0, import_react25.useState)({
    level: 0,
    isCharging: false
  });
  (0, import_react25.useEffect)(() => {
    if (navigator.getBattery) {
      navigator.getBattery().then((battery) => {
        const batteryLevel = parseInt((battery.level * 100).toString());
        const betteryCharging = battery.charging;
        setBatteryStatus({
          level: batteryLevel,
          isCharging: betteryCharging
        });
      });
    }
    const handleBatteryLevelChange = () => {
      navigator.getBattery().then((battery) => {
        const batteryLevel = parseInt((battery.level * 100).toString());
        const betteryCharging = battery.charging;
        setBatteryStatus({
          level: batteryLevel,
          isCharging: betteryCharging
        });
      });
    };
    navigator.getBattery().then((battery) => {
      battery.addEventListener("chargingchange", handleBatteryLevelChange);
      battery.addEventListener("levelchange", handleBatteryLevelChange);
    });
    return () => {
      navigator.getBattery().then((battery) => {
        battery.removeEventListener("chargingchange", handleBatteryLevelChange);
        battery.removeEventListener("levelchange", handleBatteryLevelChange);
      });
    };
  }, []);
  return batteryStatus;
}

// node_modules/react-haiku/dist/hooks/useFullscreen.js
var import_react26 = __toESM(require_react());
function useFullscreen(targetRef) {
  const [isFullscreen, setFullscreen] = (0, import_react26.useState)(false);
  const toggleFullscreen = (0, import_react26.useCallback)(() => {
    if (isFullscreen) {
      switch (true) {
        case "exitFullscreen" in document:
          document.exitFullscreen();
          break;
        case "mozCancelFullScreen" in document:
          document.mozCancelFullScreen();
          break;
        case "webkitExitFullscreen" in document:
          document.webkitExitFullscreen();
          break;
        case "msExitFullscreen" in document:
          document.msExitFullscreen();
          break;
        default:
          console.log("Fullscreen API is not supported.");
          break;
      }
    } else {
      if (targetRef.current) {
        switch (true) {
          case "requestFullscreen" in targetRef.current:
            targetRef.current.requestFullscreen();
            break;
          case "mozRequestFullScreen" in targetRef.current:
            targetRef.current.mozRequestFullScreen();
            break;
          case "webkitRequestFullscreen" in targetRef.current:
            targetRef.current.webkitRequestFullscreen();
            break;
          case "msRequestFullscreen" in targetRef.current:
            targetRef.current.msRequestFullscreen();
            break;
          default:
            console.log("Fullscreen API is not supported.");
            break;
        }
      }
    }
    setFullscreen((prevState) => !prevState);
  }, [isFullscreen, targetRef]);
  const handleFullscreenChange = (0, import_react26.useCallback)(() => {
    setFullscreen(!!document.fullscreenElement);
  }, []);
  (0, import_react26.useEffect)(() => {
    document.addEventListener("fullscreenchange", handleFullscreenChange);
    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
    };
  }, [handleFullscreenChange]);
  return { isFullscreen, toggleFullscreen };
}

// node_modules/react-haiku/dist/hooks/useDeviceOS.js
var useDeviceOS = () => {
  const { platform } = (navigator == null ? void 0 : navigator.userAgentData) || {};
  if (!!platform) {
    return platform;
  }
  return checkOSBasedOnAgentInfo(navigator.userAgent);
};
var checkOSBasedOnAgentInfo = (info) => {
  switch (true) {
    case (info.includes("iPhone") || info.includes("iPad")):
      return "iOS";
    case info.includes("Linux"):
      return "Linux";
    case info.includes("Windows"):
      return "Windows";
    default:
      return extractUniqueOS(info);
  }
};
var extractUniqueOS = (info) => {
  const regex = /\(([^)]+)\)/;
  const matches = info.match(regex);
  if (matches && matches.length > 1) {
    const deviceText = matches[1];
    const firstWord = deviceText == null ? void 0 : deviceText.trim().split(" ")[0];
    return firstWord == null ? void 0 : firstWord.slice(0, -1);
  }
  return "Unknown";
};

// node_modules/react-haiku/dist/hooks/useNetwork.js
var import_react27 = __toESM(require_react());
function useNetwork() {
  const [isOnline, setIsOnline] = (0, import_react27.useState)((navigator == null ? void 0 : navigator.onLine) || true);
  const handleOnline = (0, import_react27.useCallback)(() => {
    setIsOnline(true);
  }, []);
  const handleOffline = (0, import_react27.useCallback)(() => {
    setIsOnline(false);
  }, []);
  useEventListener("online", handleOnline);
  useEventListener("offline", handleOffline);
  return isOnline;
}

// node_modules/react-haiku/dist/hooks/useTabNotification.js
var import_react28 = __toESM(require_react());
function useTabNotification(flashDelayInSeconds = 2) {
  var _a;
  const [originalTitle] = (0, import_react28.useState)(document.title);
  let defaultFavicon = (_a = document.querySelector("link[rel$=icon]")) == null ? void 0 : _a.getAttribute("href");
  const [favicon] = (0, import_react28.useState)(defaultFavicon);
  const [notificationFavicon, setNotificationFavicon] = (0, import_react28.useState)(defaultFavicon);
  const [titlePrefix, setTitlePrefix] = (0, import_react28.useState)(null);
  const [customTitle, setCustomTitle] = (0, import_react28.useState)(null);
  const [modifiedTitle, setModifiedTitle] = (0, import_react28.useState)("");
  const [flashMessage, setFlashMessage] = (0, import_react28.useState)(null);
  const [isShown, setIsShown] = (0, import_react28.useState)(false);
  const [showFaviconDot, setShowFaviconDot] = (0, import_react28.useState)(true);
  const [faviconDotColor, setFaviconDotColor] = (0, import_react28.useState)("#f00000");
  (0, import_react28.useEffect)(() => {
    if (showFaviconDot && isShown && favicon) {
      const img = document.createElement("img");
      img.src = favicon;
      img.onload = () => {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;
        context.drawImage(img, 0, 0, img.width, img.height);
        context.beginPath();
        context.arc(img.width - img.width / 5, img.height / 5, img.width / 5, 0, 2 * Math.PI);
        context.fillStyle = faviconDotColor;
        context.fill();
        setNotificationFavicon(canvas.toDataURL("image/png"));
      };
    } else {
      setNotificationFavicon(favicon);
    }
  }, [showFaviconDot, favicon, faviconDotColor, isShown]);
  (0, import_react28.useEffect)(() => {
    var _a2;
    if (notificationFavicon) {
      (_a2 = document.querySelector("link[rel$=icon]")) == null ? void 0 : _a2.setAttribute("href", notificationFavicon);
    }
  }, [notificationFavicon]);
  (0, import_react28.useEffect)(() => {
    if (!isShown) {
      setModifiedTitle(originalTitle);
    } else {
      let title = customTitle ? customTitle : originalTitle;
      if (titlePrefix) {
        title = titlePrefix + " " + title;
      }
      setModifiedTitle(title);
    }
  }, [titlePrefix, originalTitle, customTitle, isShown]);
  (0, import_react28.useEffect)(() => {
    document.title = modifiedTitle;
  }, [modifiedTitle]);
  (0, import_react28.useEffect)(() => {
    let interval = null;
    if (flashMessage && isShown) {
      interval = setInterval(() => {
        document.title = document.title === flashMessage ? modifiedTitle : flashMessage;
      }, flashDelayInSeconds * 1e3);
    }
    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [flashMessage, modifiedTitle, isShown, flashDelayInSeconds]);
  return {
    setTitlePrefix,
    setFlashMessage,
    isShown,
    setIsShown,
    setCustomTitle,
    setShowFaviconDot,
    setFaviconDotColor
  };
}

// node_modules/react-haiku/dist/hooks/useOrientation.js
var import_react29 = __toESM(require_react());
var useOrientation = () => {
  const [orientation, setOrientation] = (0, import_react29.useState)(window.matchMedia("(orientation: portrait)").matches ? "portrait" : "landscape");
  (0, import_react29.useEffect)(() => {
    const handleOrientationChange = (e) => {
      setOrientation(e.matches ? "portrait" : "landscape");
    };
    const portraitMediaQuery = window.matchMedia("(orientation: portrait)");
    portraitMediaQuery.addEventListener("change", handleOrientationChange);
    return () => portraitMediaQuery.removeEventListener("change", handleOrientationChange);
  }, []);
  return orientation;
};

// node_modules/react-haiku/dist/hooks/useWindowSize.js
var import_react30 = __toESM(require_react());
var useWindowSize = () => {
  const [windowSize, setWindowSize] = (0, import_react30.useState)({
    width: (window == null ? void 0 : window.innerWidth) || 0,
    height: (window == null ? void 0 : window.innerHeight) || 0
  });
  (0, import_react30.useEffect)(() => {
    const handleResize = () => {
      if (typeof window !== "undefined") {
        setWindowSize({
          width: window.innerWidth,
          height: window.innerHeight
        });
      }
    };
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return windowSize;
};

// node_modules/react-haiku/dist/hooks/useIntersectionObserver.js
var import_react31 = __toESM(require_react());
var useIntersectionObserver = ({ animateOnce = false, options = {} } = {}) => {
  const observeRef = (0, import_react31.useRef)(null);
  const [isVisible, setIsVisible] = (0, import_react31.useState)(false);
  if (typeof IntersectionObserver === "undefined") {
    console.warn("IntersectionObserver is not supported in this browser.");
    return { observeRef, isVisible: true };
  }
  (0, import_react31.useEffect)(() => {
    const currentRef = observeRef.current;
    if (!currentRef)
      return;
    const observer = new IntersectionObserver((entries) => {
      const entry = entries[0];
      if (!entry)
        return;
      setIsVisible(entry.isIntersecting);
      if (entry.isIntersecting && animateOnce) {
        observer.disconnect();
      }
    }, options);
    observer.observe(currentRef);
    return () => {
      observer.disconnect();
    };
  }, [observeRef, animateOnce, options]);
  return { observeRef, isVisible };
};

// node_modules/react-haiku/dist/hooks/usePreventBodyScroll.js
var import_react32 = __toESM(require_react());
var ScrollState;
(function(ScrollState2) {
  ScrollState2["SCROLL"] = "";
  ScrollState2["LOCK"] = "hidden";
})(ScrollState || (ScrollState = {}));
function usePreventBodyScroll() {
  const [isScrollLocked, setIsScrollLocked] = (0, import_react32.useState)(false);
  (0, import_react32.useEffect)(() => {
    if (isScrollLocked) {
      document.body.style.overflow = ScrollState.LOCK;
    } else {
      document.body.style.overflow = ScrollState.SCROLL;
    }
    return () => {
      document.body.style.overflow = ScrollState.SCROLL;
    };
  }, [isScrollLocked]);
  const toggleScrollLock = () => setIsScrollLocked((prevState) => !prevState);
  return {
    isScrollLocked,
    setIsScrollLocked,
    toggleScrollLock
  };
}

// node_modules/react-haiku/dist/utils/If.js
var If = ({ isTrue, children }) => isTrue ? children : null;

// node_modules/react-haiku/dist/utils/Show.js
var import_react33 = __toESM(require_react());
var Show = ({ children }) => {
  let when = null;
  let otherwise = null;
  import_react33.Children.forEach(children, (child) => {
    if (child.props.isTrue === void 0) {
      otherwise = child;
    } else if (!when && child.props.isTrue === true) {
      when = child;
    }
  });
  return when || otherwise;
};
Show.When = If;
Show.Else = ({ render, children }) => render ? render() : children;

// node_modules/react-haiku/dist/utils/For.js
var import_react34 = __toESM(require_react());
var For = ({ render, each }) => import_react34.Children.toArray(each.map((item, index) => render(item, index)));

// node_modules/react-haiku/dist/utils/RenderAfter.js
var import_react35 = __toESM(require_react());
function RenderAfter({ delay = 1e3, children }) {
  const [ready, setReady] = (0, import_react35.useState)(false);
  (0, import_react35.useEffect)(() => {
    const timer = setTimeout(() => setReady(true), delay);
    return () => clearTimeout(timer);
  }, [ready]);
  return ready ? children : null;
}

// node_modules/react-haiku/dist/utils/Class.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var Class = ({ className = "", condition = false, toggleClass = "", children, as: Component = "div", ...props }) => {
  const computedClassName = condition ? `${className} ${toggleClass}`.trim() : className;
  return (0, import_jsx_runtime.jsx)(Component, { className: computedClassName, ...props, children });
};

// node_modules/react-haiku/dist/utils/Image.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var Image = ({ src, loading, alt, fallback, ...props }) => {
  const handleBrokenImage = (event) => event.target.src = fallback;
  return (0, import_jsx_runtime2.jsx)("img", { src, loading, alt, onError: handleBrokenImage, ...props });
};
export {
  Class,
  For,
  If,
  Image,
  RenderAfter,
  Show,
  useBatteryStatus,
  useBoolToggle,
  useClickOutside,
  useClipboard,
  useConfirmExit,
  useCookie,
  useCookieListener,
  useDebounce,
  useDeviceOS,
  useEventListener,
  useFavicon,
  useFirstRender,
  useFullscreen,
  useHold,
  useHover,
  useIdle,
  useInputValue,
  useIntersectionObserver,
  useInterval,
  useIsomorphicLayoutEffect,
  useLeaveDetection,
  useLocalStorage,
  useMediaQuery,
  useMousePosition,
  useNetwork,
  useOrientation,
  usePrefersTheme,
  usePreventBodyScroll,
  useScript,
  useScrollPosition,
  useSingleEffect,
  useSize,
  useTabNotification,
  useTitle,
  useToggle,
  useUpdateEffect,
  useUrgentUpdate,
  useWindowSize
};
//# sourceMappingURL=react-haiku.js.map
